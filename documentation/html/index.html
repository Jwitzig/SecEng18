<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Compiler for a Specification Language for Core-based Security Models: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Compiler for a Specification Language for Core-based Security Models
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Main Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#building">Building</a></li>
<li class="level1"><a href="#usage">Usage</a></li>
<li class="level1"><a href="#overview">Overview</a><ul><li class="level2"><a href="#scanner">Scanner &amp; Parser</a></li>
<li class="level2"><a href="#worker">Worker</a></li>
<li class="level2"><a href="#generator">Generator</a></li>
<li class="level2"><a href="#driver">Driver</a></li>
<li class="level2"><a href="#logger">Logger</a></li>
<li class="level2"><a href="#ast">AST</a></li>
</ul>
</li>
<li class="level1"><a href="#syntax_tree">Abstract Syntax Tree</a><ul><li class="level2"><a href="#ast_legend">Legend</a></li>
<li class="level2"><a href="#ast_base">Abstract Syntax Tree for Abstract Base Policies</a><ul><li class="level3"><a href="#ast_base_base">Abstract Base Policies</a></li>
<li class="level3"><a href="#ast_base_condition">Conditions</a></li>
<li class="level3"><a href="#ast_base_statement">Statements</a></li>
</ul>
</li>
<li class="level2"><a href="#ast_policy">Abstract Syntax Tree for Policies</a><ul><li class="level3"><a href="#ast_policy_policy">Policy</a></li>
<li class="level3"><a href="#ast_policy_state">States</a></li>
<li class="level3"><a href="#ast_policy_condition">Conditions</a></li>
<li class="level3"><a href="#ast_policy_comparable">Comparables</a></li>
</ul>
</li>
<li class="level2"><a href="#addition">Additional Language</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="building"></a>
Building</h1>
<dl>
<dt>make </dt>
<dd>Build the language compiler </dd>
<dt>make doc </dt>
<dd>Build this documentation </dd>
<dt>make clean </dt>
<dd>Clean up the generated files </dd>
</dl>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<p>In general the compiler can be started with the following command: </p><pre class="fragment">./lang &lt;policy-file&gt;
</pre><p>Additionally, the compiler accepts the following options:</p>
<dl>
<dt>-d &lt;directory&gt; </dt>
<dd>Change the directory containing the base policies. Default is the current working directory. </dd>
<dt>-f &lt;flag-list&gt; </dt>
<dd>Flags modify the behaviour of the compiler. Currently there is only one flag. NO_QUERY stops the compiler if the specification contains a query condition. </dd>
<dt>-h </dt>
<dd>Prints a help menu with the usage. </dd>
<dt>-l &lt;log-level&gt; </dt>
<dd>Defines a log level (<a class="el" href="namespacesp.html#a6be9e3e5ab8d64d8913a477b6ffc21fa">sp::log_level</a>) for the compiler to use. Valid values are INFO, WARNING and ERROR. The default log level is WARNING. </dd>
<dt>-o &lt;output-file&gt; </dt>
<dd>In general the compiler will print the result to standard output. This option redirects the result to a file. </dd>
</dl>
<p>The file name of the base policies must be equal to their name with the suffix ".base". The output C++ toplevel file allways has the name of the policy (wich is specified in the specification document)</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<h2><a class="anchor" id="scanner"></a>
Scanner &amp; Parser</h2>
<p>The scanner and parser components are responsible to read the policy files and checks the syntax of the files. There is each a scanner and a parser for the policy (<a class="el" href="classsp_1_1policy__scanner.html">sp::policy_scanner</a>, <a class="el" href="classsp_1_1policy__parser.html" title="A Bison parser. ">sp::policy_parser</a>) and the base policy (<a class="el" href="classsp_1_1base__scanner.html">sp::base_scanner</a>, <a class="el" href="classsp_1_1base__parser.html" title="A Bison parser. ">sp::base_parser</a>) specification. It generate an abstract syntax tree which is processed later on by the workers the generator. The scanner and parser is implement with the help of the programs <a href="http://flex.sourceforge.net/manual/" target="_blank"><b>Flex</b></a> and <a href="https://www.gnu.org/software/bison/manual/" target="_blank"><b>Bison</b></a>.</p>
<h2><a class="anchor" id="worker"></a>
Worker</h2>
<p>The worker performs the semantic evaluation of the presented specification. It checks the (non-)existence of identifiers and enforces the type system.</p>
<h2><a class="anchor" id="generator"></a>
Generator</h2>
<p>The XML generator (<a class="el" href="classsp_1_1xml__generator.html" title="generates the XML file ">sp::xml_generator</a>) creates the actual output. It uses the library <a href="http://grinninglizard.com/tinyxml2docs/index.html" target="_blank"><b>TinyXML-2</b></a>. The output can be validated with this <a href="lang.xsd" target="_blank"><b>XML Schema Definition</b></a>.</p>
<p>The C++ generator creates a few C++ classes wich can be used in conjunction with the Helper classes. It generates an additional XML Inputfile. All specified conditions and statements are generated no matter wether they are called by the authorization sheme.</p>
<h2><a class="anchor" id="driver"></a>
Driver</h2>
<p>The driver (<a class="el" href="classsp_1_1driver.html">sp::driver</a>) controls the execution order of the components. Also it is responsible for the information flow between the other components.</p>
<h2><a class="anchor" id="logger"></a>
Logger</h2>
<p>The logger (<a class="el" href="classsp_1_1logger.html">sp::logger</a>)</p>
<h2><a class="anchor" id="ast"></a>
AST</h2>
<p>The abstract syntax tree consists of the node classes. The <a class="el" href="classsp_1_1ast.html">sp::ast</a> node has a fix number of child nodes. The number of child nodes, their types as well as their order depend on the type of the parent node. The <a class="el" href="classsp_1_1ast__list.html" title="Syntax tree with a unknown number of children. ">sp::ast_list</a> node has an indefinite number of child nodes of the same type. The <a class="el" href="classsp_1_1ast__value.html" title="Syntax tree node with a value and no children. ">sp::ast_value</a> node does not have any child nodes, however, it contains a string value. The structure of the whole syntax tree is described below.</p>
<h1><a class="anchor" id="syntax_tree"></a>
Abstract Syntax Tree</h1>
<p>At this point, the generated syntax tree is presented. The worker and generator classes use this syntar tree to define the semantic checks and the generation of the output.</p>
<h2><a class="anchor" id="ast_legend"></a>
Legend</h2>
<p>The nodes contain the name of the node type (<a class="el" href="namespacesp.html#aa66a2a96b8bafdf01d19b851e204fc7d" title="defines the AST ">sp::ast_type</a>). The different node classes are highlighted by the color and the shape of the class. The "place holder" nodes display <b>NOT</b> a node of the syntax tree, rather, they represent a sub tree with the corresponding name. </p><div class="image">
<img src="legend_nodes.png" alt="legend_nodes.png"/>
</div>
<p>The edges show which child nodes a certain type of node has. </p><div class="image">
<img src="legend_edges.png" alt="legend_edges.png"/>
</div>
<h2><a class="anchor" id="ast_base"></a>
Abstract Syntax Tree for Abstract Base Policies</h2>
<h3><a class="anchor" id="ast_base_base"></a>
Abstract Base Policies</h3>
<p> <div class="image"><a href="base_policy_ast.png"><img src="base_policy_ast.png" alt="base_policy_ast.png"/></a></div> </p>
<h3><a class="anchor" id="ast_base_condition"></a>
Conditions</h3>
<p> <div class="image"><a href="base_policy_ast_condition.png"><img src="base_policy_ast_condition.png" alt="base_policy_ast_condition.png"/></a></div> </p>
<h3><a class="anchor" id="ast_base_statement"></a>
Statements</h3>
<p> <div class="image"><a href="base_policy_ast_statement.png"><img src="base_policy_ast_statement.png" alt="base_policy_ast_statement.png"/></a></div> </p>
<h2><a class="anchor" id="ast_policy"></a>
Abstract Syntax Tree for Policies</h2>
<h3><a class="anchor" id="ast_policy_policy"></a>
Policy</h3>
<p> <div class="image"><a href="policy_ast.png"><img src="policy_ast.png" alt="policy_ast.png"/></a></div> </p>
<h3><a class="anchor" id="ast_policy_state"></a>
States</h3>
<p> <div class="image"><a href="policy_ast_state.png"><img src="policy_ast_state.png" alt="policy_ast_state.png"/></a></div> </p>
<h3><a class="anchor" id="ast_policy_condition"></a>
Conditions</h3>
<p> <div class="image"><a href="policy_ast_condition.png"><img src="policy_ast_condition.png" alt="policy_ast_condition.png"/></a></div> </p>
<h3><a class="anchor" id="ast_policy_comparable"></a>
Comparables</h3>
<p> <div class="image"><a href="policy_ast_comparable.png"><img src="policy_ast_comparable.png" alt="policy_ast_comparable.png"/></a></div> </p>
<h2><a class="anchor" id="addition"></a>
Additional Language</h2>
<p>The following primitive operation is legal but not represented in the diagrams above:</p>
<p>roles = roles - { (s1 : r1) }; <br />
</p>
<p>use: primitive statement to remove value r1 from roles map with key s1. <br />
 C++ Output: roles.remove(std::make_tuple(s1),r1);<br />
 XML:<br />
 <code> &lt;remove-from-mapping&gt;<br />
 &lt;mapping&gt;roles&lt;/mapping&gt;<br />
 &lt;mapping-elem&gt;<br />
 &lt;keys&gt;&lt;set-elem&gt;s1&lt;/set-elem&gt;&lt;/keys&gt;<br />
 &lt;values&gt;&lt;set-elem&gt;r1&lt;/set-elem&gt;&lt;/values&gt;<br />
 &lt;mapping-elem&gt;<br />
 &lt;/remove-from-mapping&gt; <br />
<br />
 </code> AST node name: AST_STATEMENT_DEF_INTERSECTION_MAPPING_SET </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 22 2017 18:38:16 for Compiler for a Specification Language for Core-based Security Models by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
